# Отчет о проделанной работе

## Этапы работы

- **Подготовка изолированного окружения.** Я настроил `Docker`-образ, в котором будут
  изолированно тестироватьcя решения и собиратьcя проект. 
- **Автоматизация сборки.** Я разработал систему сборки на основе `CMake`, которая
  управляет компиляцией всех компонентов проекта: бейзлайнa и моего решения, тестов, бенчмарков и т.д.
- **Упрощение взаимодействия.** Для удобства работы с проектом я создал `Makefile`,
  предоставляющий единый интерфейс с простыми командами для запуска тестов,
  бенчмарков и сессий профилирования.
- **Тестирование корректности.** Для проверки корректности того,
  что мое решение работает также как бейзлайн, я подключил библиотеку
  `GoogleTest`.
- В процессе написания тестов даже получилось обнаружить баг с переполнением в бейзлане.
- **Разработка генератора тестовых данных.** Для дальнейшей работы я разработал
  механизм генерации тестов, которые соответствуют ограничениям из условий
  задачи. В последствии на основе этих тестов я оценивал производительность
  решений.
- **Анализ производительности.** Для объективного сравнения
  перфоманса решений я подключил `Google Benchmark`. Это позволило
  мне уже ориентируясь на метрики гораздо точнее рассуждать про 
  эффективность рассматриваемых оптимизаций.
- **Профилирование кода.** В дополнение к бенчмаркам, я добавил возможность анализа
  производительности с использованием `perf` внутри
  Docker-контейнера. Это дало инструмент для поиска ботлнеков в коде и
  определения дальнейших точек роста.
- В результате проделанной работы была создана полноценная и удобная
  инфраструктура, позволяющая эффективно вести разработку, гарантировать
  корректность кода и объективно оценивать его производительность.

## Баг в бейзлайне

Почти на любом сгененированном тесте в бейзлайне переполняется cur_result:

```cpp
cur_result += p->quantity * p->price;

```
Но если скастовать количество к `uint64_t`, чтобы вычисления происходили в корректном типе,
переполнения уже не происходит:

```cpp
cur_result += static_cast<uint64_t>(p->quantity) * p->price;
```

То же самое на пару строчек ниже в добавлении остатка от `shares`.

## Чем мое решение лучше предоставленного

В контесте мое решение сильно уступает бейзлайну. Я предполагаю, что это
связано с модальностью данных в используемом тесте, или конфигурацией кешей в
тестирующей системе. С помощью бенчмарков можно увидеть, что на случайном
корректном тесте **локально мое решение обгоняет бейзлайн на ~10%-15%** ~(34.5
против 39.0) в среднем по тестам. Это статистически значимый результат и он
довольно стабильно сохраняется между разными тестами. Через `perf` можно
установить причину.

### Baseline vs. Solution

Of course. Here is the performance comparison based on the data you provided.

### Performance Summary Table: Baseline vs. Solution

| Metric | Baseline | Solution | Difference (B - S) | Change |
| :--- | :--- | :--- | :--- | :--- |
| **Execution Time (Google Benchmark)** | | | | |
| Mean Time (ms) | 39.47 | 35.01 | **+4.46** | `+11.30%` |
| **CPU Pipeline (Perf)** | | | | |
| cycles | 145.13 B | 148.86 B | **-3.73 B** | `-2.57%` |
| instructions | 533.05 B | 544.00 B | **-10.95 B** | `-2.05%` |
| branch-misses | 205.21 M | 199.31 M | **+5.90 M** | `+2.87%` |
| **Cache & Memory (Perf)** | | | | |
| L1-dcache-load-misses | 378.80 M | 431.80 M | **-53.00 M** | `-13.99%` |
| L1-icache-load-misses | 6.93 M | 7.23 M | **-0.30 M** | `-4.33%` |
| dTLB-load-misses | 4.80 M | 5.18 M | **-0.38 M** | `-7.92%` |
| iTLB-loads | 89.48 K | 227.31 K | **-137.83 K** | `-154.03%` |
| iTLB-load-misses | 1.82 M | 1.84 M | **-0.02 M** | `-1.10%` |

*B = Billions, M = Millions, K = Thousands.*

---

По метрикам локальности выглядит, как будто решение сильно ухудшилось, однако
время исполнения уменьшилось довольно значительно. Сильно увеличились большие промахи в
`iTLB-loads`, я предполагаю, что это может быть
связанно с тем, что я передвинул внутрь цикла подсчет shares и это ухудшило
локальность инструкций. Однако несмотря на плохую локальность, код работает быстрее на моей машине.
Я предполагаю, что в тестирующей системе размер хешей меньше, чем у меня и локальность влияет больше, чем структура кода (не знаю, почему еще мой код может быть быстрее). Также возможно, что в контесте много небольших тестов, на которых локальность кода и данных сильно важнее других показателей кода.


## Итоги

Мое решение корректнее бейзлайна (исправлен баг с переполнение) и на моей машине быстрее на ~10-15%, однако проигрывает бейзлайну на приватном тесте в контесте.

Как показывает `perf`, эта скорость достигнута ценой ухудшения локальности кода.
Это привело к частым обращениям к `iTLB`.

*Все эксперименты можно воспроизвести на любой машине, достаточно развернуть `Docker`-образ* с помощью докер файла. 
